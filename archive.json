{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-11-07T00:16:07.815324+00:00",
  "repo": "rgwilton/draft-yp-observability",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 4,
      "id": "I_kwDOM-PT7s6czIPB",
      "title": "Initial review -00",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/4",
      "state": "OPEN",
      "author": "earies",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "First - Thx @rgwilton for kicking this document off!  This calls out what I consider as common (unresolved and often not discussed) problem statements across YANG-based telemetry consumption methods not limited to YP that should likely be cascaded into other similar initiatives.\r\n\r\nAn initial comparison and differentiation I'd like to draw from current YANG-based telemetry export methods where there is often assumed a global tree/root that represents a system-wide view is what we generally see in compute-based telemetry.  In the compute space, what is generally seen is more comparable to \"per-application\" (or per container, tenant, etc..) schema sets where application metrics, traces, etc.. is categorized as independent non-relational data-sets.\r\n\r\ne.g.\r\n* [fb303](https://github.com/facebook/fb303)\r\n* [otel](https://github.com/open-telemetry)\r\n\r\nAs data is marshaled to offline storage, various metadata can be prepended (source host, application, etc..) to formulate the unique keys within a global namespace.  Any associations or aggregation between application data is a downstream responsibility thus less importance around a single device level schema with unique and relational data or any expectations around delivery of consolidated and ordered content across applications.\r\n\r\nI believe the YANG-centric network-element world has created some unique perceptions likely stemming from classical monolithical approaches over the years.  IMO, it does not need to be this way and think this comparison is worthy of calling out especially when it comes to the complexities mentioned here.\r\n\r\nI'll post as close to inline comments pulling subsections from the current publish at time of this issue creation.\r\n\r\n_Section 2._\r\n> As such, it is helpful for the encoded instance data to be rooted at the subscription path rather than at the schema root of the operational datastore.\r\n\r\n* To clarify, `subscription-path` is the requested interesting data in which a `target-path` can be 1 or more child paths serviced by separate producers?\r\n\r\n_Section 2.1_\r\n\r\n* Completely agree with what this section is conveying and speaking on behalf of another implementation, this is precisely our approach as well.  Some amount of data can be collocated and centralized while high-scale, frequently changing data is distributed.  How data is distributed in the system often does not align with the structural assumptions of the consumer facing data-model (especially true in the context of alien modeling defined abstract to the underlying implementation).\r\n\r\n_Section 3.1_\r\n\r\n* +1 to reducing this down to a common message format.  This aligns w/ gNMI-isms and easier consumer handling to just override (update) existing keys, add keys or delete keys without applying extensive logic\r\n* Can you elaborate on (2)?  I believe your intention here is that subtrees can be delivered without any assumption of PDU aggregation according to the requested path.  What is the intention around \"This allows messages to be slightly less indented\"?\r\n\r\n_Section 3.2_\r\n\r\n* In gNMI, I believe the comparison here would be an on-change subscription with a `heartbeat-interval` essentially merging the 2 \"stream modes\"\r\n* Does this warrant an entirely different \"update-trigger\" ?\r\n\r\n_Section 3.3_\r\n\r\n* Section (1) I believe is somewhat describing another gNMI concept and desirable intent regarding the use of an `origin` whereas a piece of metadata may describe the overall \"dataset\" thus removing the need to encode the complexity of prefixes (or namespaces).  Operationally speaking, these are unnecessary complexities but as you rightly point out, assurance of non-overlap is necessary (design time)\r\n* Section (3) For sub-subscriptions, ime there is a necessity to tie back _why_ this occurred back to the consumer (why is the request split up on the implementation).  In gNMI, this is often misinterpreted and not conveyed well in that k/v pairs are to be delivered w/o any expectation of aggregation (at least for PROTO TypedVal encoding)\r\n* Section (4) - Is there a specific concern of configured vs. dynamic here?  I can't think of any current reason why there should be any differences as a request is a request encoded the same\r\n* Section (5/6) - IMO this document is helping take previous work to reality and sanity.  Without this is what is currently published operationally sane?  I would argue no - thus the final outcome is a complex collection of documents that drive a final usable solution.  Likely one of the following `An alternative approach could be to write a RFC 8641-bis, or a 'YANG-Push lite'.` rather makes sense to me.\r\n* Section (7) - If we consider dynamic subscriptions, a single client (receiver) could dictate separate parameters.  For configured subscriptions do you see any reason to change this behavior?\r\n* Section (9) - I think starting at common use-cases is the best approach.  I agree that full XPath support is likely not a goal here (especially since this can convey extreme complexity that mismatches the producer fanout on the implementation).  As you know, this same problem statement exists in gNMI with very little filtering capabilities defined today.  Some common desirable filters to date off the top of my head\r\n  * Targeting of non-key leafs\r\n  * Targeting a match on a non-key leaf to return sibling content\r\n  * Targeting a match on a non-key leaf to return the parent key and all of its children\r\n  * Targeting a match on a non-key leaf to return the parent key and _some_ children (e.g. level of depth)\r\n\r\n_Section 3.4.2_\r\n\r\n* `dampening-period` - is there any reason to define this now?  Is there intention to implement or use?\r\n* `incomplete` - Does this not create a potential for misuse and unclear expectations?  Any reason to define this now?\r\n\r\n_Examples_\r\n\r\n* As we embark upon defining sub-subscriptions, a valuable piece of data is the actual producer in the system itself (e.g. the application).  Shall we discuss the potential for additional metadata or leave that to further augmentations?\r\n* In relation to the `incomplete` node definition mentioned above, essentially what is being conveyed here is that a subtree is to be delivered in full and _if_ a node is missing then it is assumed that the receiver should consider that node deleted correct?  If `incomplete` were to be set then the receiver should not delete?  As data is segmented downstream (assuming you take a single timestamp) and take many k/v pairs from a single PDU what you might see then in that case is that missing node to not be updated (and potentially expire in TSDBs, etc..)\r\n\r\n_Random Thoughts_\r\n\r\nIn comparison again, gNMI subscriptions are built around the packing of data not per model branch but rather ensuring the goal of timestamp accuracy (which prefix aggregation as a secondary possibility).  It seems as though the data content packing per a model-set is treated with more importance here.  Assuming an on-change subscription and if a node in a subtree changes -> a notification is generated, the observation-time would then reflect that node that has changed but we are then packing a larger PDU with surrounding siblings according to the visiblity/responsibilty of said datasource.  It is then not clear \"which\" node changed without further inspection.  If the downstream receiver is taking the chunk of data, splitting k/v pairs and associating a timestamp would it not appear that all nodes were \"refreshed\"?  Only a comparison to a previous value in storage indicates which node changed.\r\n\r\nThe focus on timestamp accuracy first also works in conjunction with the k/v approach in that PDUs can be packed in the worst case scenario as a single k/v per Notification.  Am a bit torn on the mandates around data packing here in general (not new to this doc)",
      "createdAt": "2024-11-02T17:33:02Z",
      "updatedAt": "2024-11-02T17:33:02Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOM-PT7s5_U7md",
      "title": "Rgwilton initial revision",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/1",
      "state": "MERGED",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-21T14:04:52Z",
      "updatedAt": "2024-10-21T14:49:00Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "62558a10c783834c83bd41f198d1fc56aa68bfcb",
      "headRepository": "rgwilton/draft-yp-observability",
      "headRefName": "rgwilton-initial-revision",
      "headRefOid": "b42ff8be18060b7b19aae73ae397ae5934858ac7",
      "closedAt": "2024-10-21T14:49:00Z",
      "mergedAt": "2024-10-21T14:49:00Z",
      "mergedBy": "rgwilton",
      "mergeCommit": {
        "oid": "df557872aa90384a2de7d5c567e5d492444c3125"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOM-PT7s5_YETj",
      "title": "Rgwilton initial revision",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/2",
      "state": "MERGED",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-21T21:07:22Z",
      "updatedAt": "2024-10-21T21:09:08Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "8bf2842c41ba3384b7086696703acbe84a30f395",
      "headRepository": "rgwilton/draft-yp-observability",
      "headRefName": "rgwilton-initial-revision",
      "headRefOid": "2d92e8d09e1f142208ae94bb34574dd7b7301784",
      "closedAt": "2024-10-21T21:09:01Z",
      "mergedAt": "2024-10-21T21:09:01Z",
      "mergedBy": "rgwilton",
      "mergeCommit": {
        "oid": "ce4b85ad251fef2e90bc0a6b5b44f5305e6ba2b8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "PR_kwDOM-PT7s5_YGhB",
      "title": "Rgwilton initial revision",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/3",
      "state": "MERGED",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-21T21:14:17Z",
      "updatedAt": "2024-10-21T21:15:07Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "ce4b85ad251fef2e90bc0a6b5b44f5305e6ba2b8",
      "headRepository": "rgwilton/draft-yp-observability",
      "headRefName": "rgwilton-initial-revision",
      "headRefOid": "fff6f25057a509a8fb6c41efe222f619c9b15195",
      "closedAt": "2024-10-21T21:15:01Z",
      "mergedAt": "2024-10-21T21:15:01Z",
      "mergedBy": "rgwilton",
      "mergeCommit": {
        "oid": "f1fd1ed3fc3e7df6608553e0dd97c0d8bd8d9142"
      },
      "comments": [],
      "reviews": []
    }
  ]
}