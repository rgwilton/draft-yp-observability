{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-10-21T00:19:10.187541+00:00",
  "repo": "rgwilton/draft-yp-observability",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 4,
      "id": "I_kwDOM-PT7s6czIPB",
      "title": "Initial review -00",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/4",
      "state": "OPEN",
      "author": "earies",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "First - Thx @rgwilton for kicking this document off!  This calls out what I consider as common (unresolved and often not discussed) problem statements across YANG-based telemetry consumption methods not limited to YP that should likely be cascaded into other similar initiatives.\r\n\r\nAn initial comparison and differentiation I'd like to draw from current YANG-based telemetry export methods where there is often assumed a global tree/root that represents a system-wide view is what we generally see in compute-based telemetry.  In the compute space, what is generally seen is more comparable to \"per-application\" (or per container, tenant, etc..) schema sets where application metrics, traces, etc.. is categorized as independent non-relational data-sets.\r\n\r\ne.g.\r\n* [fb303](https://github.com/facebook/fb303)\r\n* [otel](https://github.com/open-telemetry)\r\n\r\nAs data is marshaled to offline storage, various metadata can be prepended (source host, application, etc..) to formulate the unique keys within a global namespace.  Any associations or aggregation between application data is a downstream responsibility thus less importance around a single device level schema with unique and relational data or any expectations around delivery of consolidated and ordered content across applications.\r\n\r\nI believe the YANG-centric network-element world has created some unique perceptions likely stemming from classical monolithical approaches over the years.  IMO, it does not need to be this way and think this comparison is worthy of calling out especially when it comes to the complexities mentioned here.\r\n\r\nI'll post as close to inline comments pulling subsections from the current publish at time of this issue creation.\r\n\r\n_Section 2._\r\n> As such, it is helpful for the encoded instance data to be rooted at the subscription path rather than at the schema root of the operational datastore.\r\n\r\n* To clarify, `subscription-path` is the requested interesting data in which a `target-path` can be 1 or more child paths serviced by separate producers?\r\n\r\n_Section 2.1_\r\n\r\n* Completely agree with what this section is conveying and speaking on behalf of another implementation, this is precisely our approach as well.  Some amount of data can be collocated and centralized while high-scale, frequently changing data is distributed.  How data is distributed in the system often does not align with the structural assumptions of the consumer facing data-model (especially true in the context of alien modeling defined abstract to the underlying implementation).\r\n\r\n_Section 3.1_\r\n\r\n* +1 to reducing this down to a common message format.  This aligns w/ gNMI-isms and easier consumer handling to just override (update) existing keys, add keys or delete keys without applying extensive logic\r\n* Can you elaborate on (2)?  I believe your intention here is that subtrees can be delivered without any assumption of PDU aggregation according to the requested path.  What is the intention around \"This allows messages to be slightly less indented\"?\r\n\r\n_Section 3.2_\r\n\r\n* In gNMI, I believe the comparison here would be an on-change subscription with a `heartbeat-interval` essentially merging the 2 \"stream modes\"\r\n* Does this warrant an entirely different \"update-trigger\" ?\r\n\r\n_Section 3.3_\r\n\r\n* Section (1) I believe is somewhat describing another gNMI concept and desirable intent regarding the use of an `origin` whereas a piece of metadata may describe the overall \"dataset\" thus removing the need to encode the complexity of prefixes (or namespaces).  Operationally speaking, these are unnecessary complexities but as you rightly point out, assurance of non-overlap is necessary (design time)\r\n* Section (3) For sub-subscriptions, ime there is a necessity to tie back _why_ this occurred back to the consumer (why is the request split up on the implementation).  In gNMI, this is often misinterpreted and not conveyed well in that k/v pairs are to be delivered w/o any expectation of aggregation (at least for PROTO TypedVal encoding)\r\n* Section (4) - Is there a specific concern of configured vs. dynamic here?  I can't think of any current reason why there should be any differences as a request is a request encoded the same\r\n* Section (5/6) - IMO this document is helping take previous work to reality and sanity.  Without this is what is currently published operationally sane?  I would argue no - thus the final outcome is a complex collection of documents that drive a final usable solution.  Likely one of the following `An alternative approach could be to write a RFC 8641-bis, or a 'YANG-Push lite'.` rather makes sense to me.\r\n* Section (7) - If we consider dynamic subscriptions, a single client (receiver) could dictate separate parameters.  For configured subscriptions do you see any reason to change this behavior?\r\n* Section (9) - I think starting at common use-cases is the best approach.  I agree that full XPath support is likely not a goal here (especially since this can convey extreme complexity that mismatches the producer fanout on the implementation).  As you know, this same problem statement exists in gNMI with very little filtering capabilities defined today.  Some common desirable filters to date off the top of my head\r\n  * Targeting of non-key leafs\r\n  * Targeting a match on a non-key leaf to return sibling content\r\n  * Targeting a match on a non-key leaf to return the parent key and all of its children\r\n  * Targeting a match on a non-key leaf to return the parent key and _some_ children (e.g. level of depth)\r\n\r\n_Section 3.4.2_\r\n\r\n* `dampening-period` - is there any reason to define this now?  Is there intention to implement or use?\r\n* `incomplete` - Does this not create a potential for misuse and unclear expectations?  Any reason to define this now?\r\n\r\n_Examples_\r\n\r\n* As we embark upon defining sub-subscriptions, a valuable piece of data is the actual producer in the system itself (e.g. the application).  Shall we discuss the potential for additional metadata or leave that to further augmentations?\r\n* In relation to the `incomplete` node definition mentioned above, essentially what is being conveyed here is that a subtree is to be delivered in full and _if_ a node is missing then it is assumed that the receiver should consider that node deleted correct?  If `incomplete` were to be set then the receiver should not delete?  As data is segmented downstream (assuming you take a single timestamp) and take many k/v pairs from a single PDU what you might see then in that case is that missing node to not be updated (and potentially expire in TSDBs, etc..)\r\n\r\n_Random Thoughts_\r\n\r\nIn comparison again, gNMI subscriptions are built around the packing of data not per model branch but rather ensuring the goal of timestamp accuracy (which prefix aggregation as a secondary possibility).  It seems as though the data content packing per a model-set is treated with more importance here.  Assuming an on-change subscription and if a node in a subtree changes -> a notification is generated, the observation-time would then reflect that node that has changed but we are then packing a larger PDU with surrounding siblings according to the visiblity/responsibilty of said datasource.  It is then not clear \"which\" node changed without further inspection.  If the downstream receiver is taking the chunk of data, splitting k/v pairs and associating a timestamp would it not appear that all nodes were \"refreshed\"?  Only a comparison to a previous value in storage indicates which node changed.\r\n\r\nThe focus on timestamp accuracy first also works in conjunction with the k/v approach in that PDUs can be packed in the worst case scenario as a single k/v per Notification.  Am a bit torn on the mandates around data packing here in general (not new to this doc)",
      "createdAt": "2024-11-02T17:33:02Z",
      "updatedAt": "2024-11-02T17:33:02Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOM-PT7s6uw3RZ",
      "title": "Reshad's high-level comments",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/8",
      "state": "OPEN",
      "author": "reshad-equinix",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Couple of high-level questions/comments:\n\n- There is no text on (the lack of) backwards compatibility with existing RFC8639/41 YP implementations. The intro mentions that they can be implemented alongside each other but how does e.g. a client, which implements both, decide which to pick when subscribing to a server. Is this based on the yp-lite-capabilities in section 12.1? Do we need a new NETCONF capability?\n\n- I'm not a fan of the term yp-lite, although I understand why it was chosen. You have removed some functionality from YP, but yp-lite also has extra functionality and looking at the YANG module+tree, it does not seem to be \"lite\". And if someday we'd need another version of YP, would we call it \"yp-liter\" or \"yp-not-as-lite\" :-) Personally I'd go for something as boring as YPv2.\n",
      "createdAt": "2025-03-19T14:37:59Z",
      "updatedAt": "2025-10-03T16:09:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "To answer the first question:\nYP Lite will be a separate config tree and use separate RPCs, with separate capabilities.  I.e., it is in essence a separate protocol.\n\nI don't think that we should add a NETCONF capability for this since this feature is really orthogonal to the NETCONF protocol.",
          "createdAt": "2025-10-03T16:09:00Z",
          "updatedAt": "2025-10-03T16:09:00Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOM-PT7s7NFR2H",
      "title": "Should we move YP configuration model into a separate draft?  Or alternatively, in it's own section?",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/9",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "There is a suggestion to move YP configuration into a separate draft.\nAn alternative approach could just put it into it's own section of the document.\n\nJames (and I think Ebben) would like this for a few reasons:\n- Implementations might implement YP LIte, but not the IETF configuration/oper YANG model (which are currently getting less traction in the industry)\n\nIt may have some other benefits:\n- It would make the YP LIte document shorter, but it might also make it less readable, or harder to describe.\n\nQuestion (Thomas): Would there be a normative reference to the configuration model?\nQuestion (Rob): What about the notifications/RPCs/types/etc?  Having all of these in one model has some benefits of shorter/simpler paths.  I think that this would force the structure into more modules. (E.g., types, notifications, config/state, rpcs, capabilities).\nQuestion (Rob): What about examples?  Would they be in this document (as informative references), or a separate doc?\n\nNote, the WG was also asked and the current indication was to keep it together in a single doc (but we could still potentially structure it into separate sections).",
      "createdAt": "2025-09-22T12:22:52Z",
      "updatedAt": "2025-10-15T09:33:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "More thoughts:\n\nIf we were to split then I think that this would mean two modules:\n(1) Covering types, notifications (in the base draft), any common groupings, and probably the RPCs for dynamic subscriptions.\n(2)A separate module cover the configuration/oper model.",
          "createdAt": "2025-09-26T09:28:07Z",
          "updatedAt": "2025-09-26T09:28:07Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Discussion on 26th Sept:\n- RPCs, Notifications, types stay in the core draft.\n- Configuration (and hence operational tree as well, since they are co-located) move to a separate yang-push-lite-config.yang module.\n\nIf we pull out the configuration tree then this has an impact on whether/how dynamic subscriptions may reference a configured subscription (but could just move to an augment of the configuration model).",
          "createdAt": "2025-10-03T12:58:40Z",
          "updatedAt": "2025-10-03T12:58:40Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "James is questioning whether a dynamic subscription needs to be able to reference a configured filter?  Also raises the issue of what happens to the dynamic subscription if the referenced configured filter changes ... perhaps better to just remove this capability to keep YANG Push Lite.",
          "createdAt": "2025-10-03T14:25:52Z",
          "updatedAt": "2025-10-03T14:25:52Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOM-PT7s7PiBFw",
      "title": "update-complete notification (and incomplete flag)",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/10",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The latest draft has an update-complete notification (although possibly should be renamed as end-of-update, both as a flag to the update notification and as an independent update-complete notification.\n\nThe expectation is that all notifications for a given periodic collection or on-change event (create/update or delete) MUST use the same event-time in the notification envelope:\n - we are also considering whether to also include, or use a numeric collection-id to correlate, but that would mean sending an extra field in every message.  I don't think that we need two field to correlate on.\n\nExisting yang-push defined an \"incomplete\" flag on a notification, but there are questions about whether this is really useful/required.  Questions/comments raised in discussion were:\n- can/will servers be able to set this field?\n- what would clients do if they received this field?  E.g., don't delete data items that you haven't heard about.\n- would it be better if the flag just indicated the end of a collection period with less emphasis on whether it was complete or not? E.g., \"update-end\" rather than \"update-complete\"\n- is a server allowed to just not include some data (rather than delay sending it) in a periodic update?\n- if we do have separate incomplete/complete flags then definitely need to rename, could use an enum (with a default to avoid encoding in the normal case), definitely need to define clearly what such flags mean (or which conditions they may be used).\n- we should try and keep this as simple as possible (i.e., take it out if it isn't needed).  But we want a solution that is complete.\n- also look at what gNMI does - although that isn't really a great/complete specification in this area.\n\nOther questions that came up in internal discussions are:\n - Is a server just allowed to delay sending updates until it is able to, and then eventually sends an update-complete?\n - If you can't queue the traffic then just tear down the connection - I think that this has been previously suggested/agreed.\n - If you get stuck waiting, i.e., don't time out, then we would just delay sending the update-complete notification.",
      "createdAt": "2025-10-03T16:56:49Z",
      "updatedAt": "2025-10-07T14:26:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "My current thinking is that we should remove the incomplete flag, but perhaps put a tighter constraint on sending an update-complete notification (or setting the \"complete\" flag - renamed from \"update-complete\") in an update notification.\n\nI.e., when a client processes this notification is should be able to infer that if is hasn't received some of the data for a periodic subscription event, and there are no gaps in the sequence-number, then that data no longer exists on the system and can be removed by the client.",
          "createdAt": "2025-10-07T14:26:39Z",
          "updatedAt": "2025-10-07T14:26:39Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOM-PT7s7Qi9jA",
      "title": "Advertising subscription schema",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/11",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The existing YP extensions allow a device to advertise the YANG module at the top of an XPath subscription.  The augmented-by allows a client, using YANG library to retrieve the descendant modules below the subscription point.  Collectively, these can be used to construct a partial YANG schema that covers the subscription nodes.  Note, in the case of OC YANG modules, that make heavy use of groupings, it is possible that some subscriptions may pull in large amounts of YANG schema nodes.\n\nAlternatively, if the clients has access to the full device schema (e.g., through YANG library, or offline YANG packages) then the subscription path could be used to construct a minimal schema that is covered by the subscription (or perhaps the minimum set of modules required to cover the particular schema).\n\nThe solution also needs a way to identify if the subscription has changed so that the schema can be reconstructed.\n\nProposal:\n- Subscription started message always includes the actual filter(s) being used (even if a configured subscription references a filter).\n- Configured subscription also include the referenced filter name, if a referenced (as opposed to inline) filter has been used.\n- We include a string field [max 128 chars] for the publisher to identify the version of the schema under the subscription.  This string field MUST change if any modules under the subscription path have changed.  This field MAY change if modules outside the subscription have changed:\n  - E.g., an accurate way (to minimise churn) would be generate an hash of the compiled schema tree at the point of the subscription (e.g., for a simple YPath subscription).  Done carefully, this should also mean that different devices by the same vendor would have the same schema.\n  - A much simpler alternative would be to include the YANG library checksum, although that is more likely to generate false-positive changes (e.g., when patches of bugfixes are generated), i.e., where the subscription schema has been reported as changed, but there are no actual changes to that part of the schema\n\nAlso consider:\n- In the case of an XPath or YPath subscription, do we also include the modules at the path of the subscription?  Ideally, I would like to find a different, more robust and complete, solution (since this would not identify if any child nodes have changed).\n- If we do move away from listing the modules then we may want a migration path.\n- Is the schema affected at all due to access-control policies (i.e., if the receiver is going to stop receiving some information).  I don't think that it should, it is arguably simpler to be tied solely to the schema.\n",
      "createdAt": "2025-10-09T11:47:51Z",
      "updatedAt": "2025-10-09T14:32:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Some comments from when this was discussed prior to IETF 122:\n   - Rob: I think that we should do this (i.e., as optimized version of content-id)\n   - Would this also be impacted by a change to access control? (Rob: Probably not)\n   - Thomas would like to align to the same mechanism in YANG Push, i.e., in the existing drafts, and we should use the same mechanism\n   - Rob: I would like to understand what the long term complete solution is here.\n   - Benoit: Also related to the data manifest draft (in WGLC in OPSWG.)\n     - Should discuss all of this together.  IETF 122 discussion.\n",
          "createdAt": "2025-10-09T14:29:22Z",
          "updatedAt": "2025-10-09T14:29:42Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOM-PT7s7QlLy9",
      "title": "update-complete notification",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/12",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This replaces the replay-complete notification and may be used on any notification:\n\n- Does this need a flag to indicate that the update-complete notification is due to an initial-sync?  I'm not convinced, but we could potentially just include the *snapshot-type* from the notification message.\n- Check that there is agreement that a single notification is better than too separate notifications (less code paths).\n\n- Should clients have to configure on each subscription that they want to receive update-complete notifications on each subscription (we could also implement a hierarchical default)?  Or is this just default behaviour and these notifications should always be generated?\n\n- Note, that I also have a working assumption that even if a subscription is effectively decomposed internally (e.g., perhaps due to multiple subscription paths) then we would only have a single update-complete notification when all internal subscriptions have completed.",
      "createdAt": "2025-10-09T14:23:12Z",
      "updatedAt": "2025-10-09T14:26:50Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOM-PT7s7Qlbbu",
      "title": "Issues related to dynamic subscription lifecycles",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/13",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "When a subscription is terminated, should it be MUST NOT send any more notifications after the terminated message, or SHOULD NOT?\n       \n      - Holger, Thomas, Benoit: MUST NOT\n      - James: SHOULD NOT\n      - MUST NOT is clearer from an implementation POV, but probably doesn't really matter.\n      - What does the receiver do when it gets this message anyway?  I.e., does a receiver check/know to ignore messages received after a subscription-terminated, or before a subscription-started?\n\nProposal: Change the draft to \"MUST NOT\" for now.\n\nRelated question on dynamic-subscriptions:\n- is a terminate-subscription RPC allowed to be asynchronous with respect to the caller.  I.e., is it allowed to return before the subscription has actually stopped?\n- is a kill-subscription RPC allowed to be asynchronous with respect to the caller.  I.e., is it allowed to return before the subscription has actually stopped?  For kill-subscription I think that it should be asynchronous - I think that makes more sense given that it generally expected to be a third party and not actively consuming the subscription.\n- Do we wait for a \"establish-subscription\" RPC to return before sending events to a client?  YP had this restriction, but I was considering removing it, but I don't know if that would make life more difficult for clients.",
      "createdAt": "2025-10-09T14:38:14Z",
      "updatedAt": "2025-10-17T10:34:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOM-PT7s7QwH42",
      "title": "On-change events",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/14",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "1. Should we allow on-change events to be published above the subscription path?\n   -  Rob: I think that the answer should be no.\n1. Should we allow on-change events to be generated even if the value may not have changed?\n   - Rob: I think that this needs to be yes, since many systems may track whether something has changed at a higher level in the data tree.  E.g., rather than tracking whether the interface MTU has changed, track whether any of a set of interface properties has changed.\n   - Ebben: How loose or tight should the specification bit.\n   - Holger: This should be okay, and this happens today.\n   - Rob: Should add comment that this shouldn't generate excessive spurious notifications. \n\n1. When subscribed to a leaf under and interface, and the interface is deleted, then what do you generate the delete notification for?\n   - Do you generate the delete for the object being subscribed to?\n   - Or do you send the delete higher up the path, at point that the object has been removed?\n   - If the messages are lifted up to object level then need to consider happen's before relationship (if this is an issue).\n   - Better soln may be to subscribe higher up to the object with a filter applied to select the fields of interface within the object.\n\n1. Should we support configurable subscription-level keepalives?\n   - This would probably entail periodically sending a small message on on-change subscriptions so that the receiver (message broker) knows that the collection is still alive and active.\n   - The presumption is that would be configurable option on an on-change subscription (configured or dynamic)\n   - Note, some transport sessions may already support keepalives, which is a separate, transport specific consideration.\n   - An alternative would be to configure a joint periodic and on-change subscription, but depending on the keepalive interval this would likely involve sending more data on a periodic basis.\n   - Another alternative is to monitor the operational state of the subscription to keep that all the expected subscriptions are active.\n   - **discussed, but no conclusion yet**",
      "createdAt": "2025-10-10T10:27:46Z",
      "updatedAt": "2025-10-16T09:30:58Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDOM-PT7s7RaC0B",
      "title": "Document check/cleanup tasks",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/15",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Document check/cleanup (mostly editorial) tasks:\n\n- [ ] Check/prune terminology, any extra, missing, consistency.\n- [ ] Remove dead/commented text in the draft.\n- [ ] Remove dead/commented code from YANG modules.\n- [ ] Check everyone has been acknowledged.\n- [ ] Check that the change list for add/update messages.\n- [ ] Add and validate examples.\n  - [ ] Some (maybe all) should be validated with the new envelope structure (which requires changes to yanglint to support that format)\n  - [ ] Update the tooling to add folding to the examples, if necessary.\n- [ ] Simplify and update the list of dependencies on the various YANG modules (once the structure of them is more stable).\n",
      "createdAt": "2025-10-14T10:14:11Z",
      "updatedAt": "2025-10-20T19:33:57Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOM-PT7s7Rq2TD",
      "title": "Advertising support for the subscription config data model",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/16",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Should this just use the standard mechanisms, i.e., whether the module is included in YANG library (RFC 8525), or should this also be listed in the Yang Push Capabilities Data Model?",
      "createdAt": "2025-10-15T11:51:56Z",
      "updatedAt": "2025-10-15T11:51:56Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 17,
      "id": "I_kwDOM-PT7s7R9LGn",
      "title": "Transport considerations for subscriptions over multiple receivers",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/17",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Note I've updated the document to allow a single configured subscription to have different transports - I was trying to avoid this to keep it simple, but as soon as you secure transports any benefit you would have disappears anyway, so the limitation doesn't really help in the general case.\n",
      "createdAt": "2025-10-16T15:49:25Z",
      "updatedAt": "2025-10-16T15:49:25Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOM-PT7s7R9Loj",
      "title": "Capabilities",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/18",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Do we need to add capabilities to indicate:\n\n1. Which fields are on-change notifiable.\n\n1. At which level *bags* exist internally (for performance reasons).\n\n1. The points at which subscriptions are decomposed to.",
      "createdAt": "2025-10-16T15:50:00Z",
      "updatedAt": "2025-10-16T15:50:00Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOM-PT7s5_U7md",
      "title": "Rgwilton initial revision",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/1",
      "state": "MERGED",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-21T14:04:52Z",
      "updatedAt": "2024-10-21T14:49:00Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "62558a10c783834c83bd41f198d1fc56aa68bfcb",
      "headRepository": "rgwilton/draft-yp-observability",
      "headRefName": "rgwilton-initial-revision",
      "headRefOid": "b42ff8be18060b7b19aae73ae397ae5934858ac7",
      "closedAt": "2024-10-21T14:49:00Z",
      "mergedAt": "2024-10-21T14:49:00Z",
      "mergedBy": "rgwilton",
      "mergeCommit": {
        "oid": "df557872aa90384a2de7d5c567e5d492444c3125"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOM-PT7s5_YETj",
      "title": "Rgwilton initial revision",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/2",
      "state": "MERGED",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-21T21:07:22Z",
      "updatedAt": "2024-10-21T21:09:08Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "8bf2842c41ba3384b7086696703acbe84a30f395",
      "headRepository": "rgwilton/draft-yp-observability",
      "headRefName": "rgwilton-initial-revision",
      "headRefOid": "2d92e8d09e1f142208ae94bb34574dd7b7301784",
      "closedAt": "2024-10-21T21:09:01Z",
      "mergedAt": "2024-10-21T21:09:01Z",
      "mergedBy": "rgwilton",
      "mergeCommit": {
        "oid": "ce4b85ad251fef2e90bc0a6b5b44f5305e6ba2b8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "PR_kwDOM-PT7s5_YGhB",
      "title": "Rgwilton initial revision",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/3",
      "state": "MERGED",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-21T21:14:17Z",
      "updatedAt": "2024-10-21T21:15:07Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "ce4b85ad251fef2e90bc0a6b5b44f5305e6ba2b8",
      "headRepository": "rgwilton/draft-yp-observability",
      "headRefName": "rgwilton-initial-revision",
      "headRefOid": "fff6f25057a509a8fb6c41efe222f619c9b15195",
      "closedAt": "2024-10-21T21:15:01Z",
      "mergedAt": "2024-10-21T21:15:01Z",
      "mergedBy": "rgwilton",
      "mergeCommit": {
        "oid": "f1fd1ed3fc3e7df6608553e0dd97c0d8bd8d9142"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 5,
      "id": "PR_kwDOM-PT7s6BL9e8",
      "title": "Jgc 01",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/5",
      "state": "CLOSED",
      "author": "jgcumming",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-11-07T13:15:26Z",
      "updatedAt": "2024-11-07T13:15:57Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "d5488db948318c4788c7b7aaffdd2648e2a6ce1d",
      "headRepository": "jgcumming/draft-yp-observability",
      "headRefName": "jgc-01",
      "headRefOid": "cb9d0e2cfb12a35071d82eb831b9f780928044a1",
      "closedAt": "2024-11-07T13:15:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 6,
      "id": "PR_kwDOM-PT7s6BMGaH",
      "title": "WIP: Updates to specify YANG push lite",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/6",
      "state": "OPEN",
      "author": "jgcumming",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-11-07T13:31:40Z",
      "updatedAt": "2025-02-04T09:58:02Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "d5488db948318c4788c7b7aaffdd2648e2a6ce1d",
      "headRepository": "jgcumming/draft-yp-observability",
      "headRefName": "jgc-01",
      "headRefOid": "6a16d71643ee9767f01036d51b3ebb85fd432aee",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "earies",
          "authorAssociation": "NONE",
          "body": "are we ready to merge this PR and iterate from there?",
          "createdAt": "2024-12-08T17:46:44Z",
          "updatedAt": "2024-12-08T17:46:44Z"
        },
        {
          "author": "jgcumming",
          "authorAssociation": "NONE",
          "body": "@rgwilton I've not had time to devote to this over the holiday period.  Feel free to merge and then continue and I'll add more changes to the merged version",
          "createdAt": "2025-02-03T22:12:57Z",
          "updatedAt": "2025-02-03T22:12:57Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "I'll need to manually merge this in because I have iterated significantly on the document.  The latest version is on the main branch in [draft-wilton-netconf-yang-push-lite.md](https://github.com/rgwilton/draft-yp-observability/blob/main/draft-wilton-netconf-yang-push-lite.md).\r\n\r\nAnd you can see the generated document here:\r\nhttps://rgwilton.github.io/draft-yp-observability/draft-wilton-netconf-yang-push-lite.html\r\n\r\nI would like to check whether you are still okay with this as a starting point and for me to add your names to this draft?",
          "createdAt": "2025-02-04T09:58:00Z",
          "updatedAt": "2025-02-04T09:58:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOM-PT7s6QcIdj",
          "commit": {
            "abbreviatedOid": "a116515"
          },
          "author": "earies",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T10:10:48Z",
          "updatedAt": "2024-11-08T10:10:49Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nThe establish-subscription operation is extended with an \"encoding\" option to determine the encoding type.  This \"encoding\" leaf is an identityref with the following defined identities: xml, json_ietf, cbor\r\n```\r\nThis enables better extensibility (should one choose to augment additional encodings at a later point)",
              "createdAt": "2024-11-08T10:10:49Z",
              "updatedAt": "2024-11-08T10:10:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOM-PT7s6RB0t4",
          "commit": {
            "abbreviatedOid": "6a16d71"
          },
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-11-13T13:35:24Z",
          "updatedAt": "2024-11-13T13:35:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOM-PT7s6MgDJ1",
      "title": "Fix replay-completed.txt reference",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/7",
      "state": "OPEN",
      "author": "earies",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-25T16:30:21Z",
      "updatedAt": "2025-02-25T16:30:21Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "b6c6f5d6672256754673adf0f8c483cb884c9969",
      "headRepository": "earies/draft-yp-observability",
      "headRefName": "replay-completed",
      "headRefOid": "2862f6a5a6a1d02d670d8f31dfe7c4414b32585b",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}