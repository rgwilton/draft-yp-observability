{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-12-11T00:20:59.688529+00:00",
  "repo": "rgwilton/draft-yp-observability",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "for discussion",
      "description": "This issue is one that we should discuss to try and make progress on.",
      "color": "d93f0b"
    },
    {
      "name": "proposed resolution",
      "description": "This issue has a proposed resolution for discussion and agreement",
      "color": "f6e000"
    },
    {
      "name": "propose closing",
      "description": "",
      "color": "ae487f"
    }
  ],
  "issues": [
    {
      "number": 4,
      "id": "I_kwDOM-PT7s6czIPB",
      "title": "Initial review -00",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/4",
      "state": "OPEN",
      "author": "earies",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "First - Thx @rgwilton for kicking this document off!  This calls out what I consider as common (unresolved and often not discussed) problem statements across YANG-based telemetry consumption methods not limited to YP that should likely be cascaded into other similar initiatives.\r\n\r\nAn initial comparison and differentiation I'd like to draw from current YANG-based telemetry export methods where there is often assumed a global tree/root that represents a system-wide view is what we generally see in compute-based telemetry.  In the compute space, what is generally seen is more comparable to \"per-application\" (or per container, tenant, etc..) schema sets where application metrics, traces, etc.. is categorized as independent non-relational data-sets.\r\n\r\ne.g.\r\n* [fb303](https://github.com/facebook/fb303)\r\n* [otel](https://github.com/open-telemetry)\r\n\r\nAs data is marshaled to offline storage, various metadata can be prepended (source host, application, etc..) to formulate the unique keys within a global namespace.  Any associations or aggregation between application data is a downstream responsibility thus less importance around a single device level schema with unique and relational data or any expectations around delivery of consolidated and ordered content across applications.\r\n\r\nI believe the YANG-centric network-element world has created some unique perceptions likely stemming from classical monolithical approaches over the years.  IMO, it does not need to be this way and think this comparison is worthy of calling out especially when it comes to the complexities mentioned here.\r\n\r\nI'll post as close to inline comments pulling subsections from the current publish at time of this issue creation.\r\n\r\n_Section 2._\r\n> As such, it is helpful for the encoded instance data to be rooted at the subscription path rather than at the schema root of the operational datastore.\r\n\r\n* To clarify, `subscription-path` is the requested interesting data in which a `target-path` can be 1 or more child paths serviced by separate producers?\r\n\r\n_Section 2.1_\r\n\r\n* Completely agree with what this section is conveying and speaking on behalf of another implementation, this is precisely our approach as well.  Some amount of data can be collocated and centralized while high-scale, frequently changing data is distributed.  How data is distributed in the system often does not align with the structural assumptions of the consumer facing data-model (especially true in the context of alien modeling defined abstract to the underlying implementation).\r\n\r\n_Section 3.1_\r\n\r\n* +1 to reducing this down to a common message format.  This aligns w/ gNMI-isms and easier consumer handling to just override (update) existing keys, add keys or delete keys without applying extensive logic\r\n* Can you elaborate on (2)?  I believe your intention here is that subtrees can be delivered without any assumption of PDU aggregation according to the requested path.  What is the intention around \"This allows messages to be slightly less indented\"?\r\n\r\n_Section 3.2_\r\n\r\n* In gNMI, I believe the comparison here would be an on-change subscription with a `heartbeat-interval` essentially merging the 2 \"stream modes\"\r\n* Does this warrant an entirely different \"update-trigger\" ?\r\n\r\n_Section 3.3_\r\n\r\n* Section (1) I believe is somewhat describing another gNMI concept and desirable intent regarding the use of an `origin` whereas a piece of metadata may describe the overall \"dataset\" thus removing the need to encode the complexity of prefixes (or namespaces).  Operationally speaking, these are unnecessary complexities but as you rightly point out, assurance of non-overlap is necessary (design time)\r\n* Section (3) For sub-subscriptions, ime there is a necessity to tie back _why_ this occurred back to the consumer (why is the request split up on the implementation).  In gNMI, this is often misinterpreted and not conveyed well in that k/v pairs are to be delivered w/o any expectation of aggregation (at least for PROTO TypedVal encoding)\r\n* Section (4) - Is there a specific concern of configured vs. dynamic here?  I can't think of any current reason why there should be any differences as a request is a request encoded the same\r\n* Section (5/6) - IMO this document is helping take previous work to reality and sanity.  Without this is what is currently published operationally sane?  I would argue no - thus the final outcome is a complex collection of documents that drive a final usable solution.  Likely one of the following `An alternative approach could be to write a RFC 8641-bis, or a 'YANG-Push lite'.` rather makes sense to me.\r\n* Section (7) - If we consider dynamic subscriptions, a single client (receiver) could dictate separate parameters.  For configured subscriptions do you see any reason to change this behavior?\r\n* Section (9) - I think starting at common use-cases is the best approach.  I agree that full XPath support is likely not a goal here (especially since this can convey extreme complexity that mismatches the producer fanout on the implementation).  As you know, this same problem statement exists in gNMI with very little filtering capabilities defined today.  Some common desirable filters to date off the top of my head\r\n  * Targeting of non-key leafs\r\n  * Targeting a match on a non-key leaf to return sibling content\r\n  * Targeting a match on a non-key leaf to return the parent key and all of its children\r\n  * Targeting a match on a non-key leaf to return the parent key and _some_ children (e.g. level of depth)\r\n\r\n_Section 3.4.2_\r\n\r\n* `dampening-period` - is there any reason to define this now?  Is there intention to implement or use?\r\n* `incomplete` - Does this not create a potential for misuse and unclear expectations?  Any reason to define this now?\r\n\r\n_Examples_\r\n\r\n* As we embark upon defining sub-subscriptions, a valuable piece of data is the actual producer in the system itself (e.g. the application).  Shall we discuss the potential for additional metadata or leave that to further augmentations?\r\n* In relation to the `incomplete` node definition mentioned above, essentially what is being conveyed here is that a subtree is to be delivered in full and _if_ a node is missing then it is assumed that the receiver should consider that node deleted correct?  If `incomplete` were to be set then the receiver should not delete?  As data is segmented downstream (assuming you take a single timestamp) and take many k/v pairs from a single PDU what you might see then in that case is that missing node to not be updated (and potentially expire in TSDBs, etc..)\r\n\r\n_Random Thoughts_\r\n\r\nIn comparison again, gNMI subscriptions are built around the packing of data not per model branch but rather ensuring the goal of timestamp accuracy (which prefix aggregation as a secondary possibility).  It seems as though the data content packing per a model-set is treated with more importance here.  Assuming an on-change subscription and if a node in a subtree changes -> a notification is generated, the observation-time would then reflect that node that has changed but we are then packing a larger PDU with surrounding siblings according to the visiblity/responsibilty of said datasource.  It is then not clear \"which\" node changed without further inspection.  If the downstream receiver is taking the chunk of data, splitting k/v pairs and associating a timestamp would it not appear that all nodes were \"refreshed\"?  Only a comparison to a previous value in storage indicates which node changed.\r\n\r\nThe focus on timestamp accuracy first also works in conjunction with the k/v approach in that PDUs can be packed in the worst case scenario as a single k/v per Notification.  Am a bit torn on the mandates around data packing here in general (not new to this doc)",
      "createdAt": "2024-11-02T17:33:02Z",
      "updatedAt": "2024-11-02T17:33:02Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOM-PT7s6uw3RZ",
      "title": "Reshad's high-level comments",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/8",
      "state": "OPEN",
      "author": "reshad-equinix",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Couple of high-level questions/comments:\n\n- There is no text on (the lack of) backwards compatibility with existing RFC8639/41 YP implementations. The intro mentions that they can be implemented alongside each other but how does e.g. a client, which implements both, decide which to pick when subscribing to a server. Is this based on the yp-lite-capabilities in section 12.1? Do we need a new NETCONF capability?\n\n- I'm not a fan of the term yp-lite, although I understand why it was chosen. You have removed some functionality from YP, but yp-lite also has extra functionality and looking at the YANG module+tree, it does not seem to be \"lite\". And if someday we'd need another version of YP, would we call it \"yp-liter\" or \"yp-not-as-lite\" :-) Personally I'd go for something as boring as YPv2.\n",
      "createdAt": "2025-03-19T14:37:59Z",
      "updatedAt": "2025-10-22T08:26:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "To answer the first question:\nYP Lite will be a separate config tree and use separate RPCs, with separate capabilities.  I.e., it is in essence a separate protocol.\n\nI don't think that we should add a NETCONF capability for this since this feature is really orthogonal to the NETCONF protocol.\n\nFor the second comment, I'm open to just calling it YPv2",
          "createdAt": "2025-10-03T16:09:00Z",
          "updatedAt": "2025-10-22T08:26:22Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOM-PT7s7NFR2H",
      "title": "Should we move YP configuration model into a separate draft?  Or alternatively, in it's own section?",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/9",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "There is a suggestion to move YP configuration into a separate draft.\nAn alternative approach could just put it into it's own section of the document.\n\nJames (and I think Ebben) would like this for a few reasons:\n- Implementations might implement YP LIte, but not the IETF configuration/oper YANG model (which are currently getting less traction in the industry)\n\nIt may have some other benefits:\n- It would make the YP LIte document shorter, but it might also make it less readable, or harder to describe.\n\nQuestion (Thomas): Would there be a normative reference to the configuration model?\nQuestion (Rob): What about the notifications/RPCs/types/etc?  Having all of these in one model has some benefits of shorter/simpler paths.  I think that this would force the structure into more modules. (E.g., types, notifications, config/state, rpcs, capabilities).\nQuestion (Rob): What about examples?  Would they be in this document (as informative references), or a separate doc?\n\nNote, the WG was also asked and the current indication was to keep it together in a single doc (but we could still potentially structure it into separate sections).",
      "createdAt": "2025-09-22T12:22:52Z",
      "updatedAt": "2025-10-15T09:33:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "More thoughts:\n\nIf we were to split then I think that this would mean two modules:\n(1) Covering types, notifications (in the base draft), any common groupings, and probably the RPCs for dynamic subscriptions.\n(2)A separate module cover the configuration/oper model.",
          "createdAt": "2025-09-26T09:28:07Z",
          "updatedAt": "2025-09-26T09:28:07Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Discussion on 26th Sept:\n- RPCs, Notifications, types stay in the core draft.\n- Configuration (and hence operational tree as well, since they are co-located) move to a separate yang-push-lite-config.yang module.\n\nIf we pull out the configuration tree then this has an impact on whether/how dynamic subscriptions may reference a configured subscription (but could just move to an augment of the configuration model).",
          "createdAt": "2025-10-03T12:58:40Z",
          "updatedAt": "2025-10-03T12:58:40Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "James is questioning whether a dynamic subscription needs to be able to reference a configured filter?  Also raises the issue of what happens to the dynamic subscription if the referenced configured filter changes ... perhaps better to just remove this capability to keep YANG Push Lite.",
          "createdAt": "2025-10-03T14:25:52Z",
          "updatedAt": "2025-10-03T14:25:52Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOM-PT7s7PiBFw",
      "title": "update-complete notification (and incomplete flag)",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/10",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The latest draft has an update-complete notification (although possibly should be renamed as end-of-update, both as a flag to the update notification and as an independent update-complete notification.\n\nThe expectation is that all notifications for a given periodic collection or on-change event (create/update or delete) MUST use the same event-time in the notification envelope:\n - we are also considering whether to also include, or use a numeric collection-id to correlate, but that would mean sending an extra field in every message.  I don't think that we need two field to correlate on.\n\nExisting yang-push defined an \"incomplete\" flag on a notification, but there are questions about whether this is really useful/required.  Questions/comments raised in discussion were:\n- can/will servers be able to set this field?\n- what would clients do if they received this field?  E.g., don't delete data items that you haven't heard about.\n- would it be better if the flag just indicated the end of a collection period with less emphasis on whether it was complete or not? E.g., \"update-end\" rather than \"update-complete\"\n- is a server allowed to just not include some data (rather than delay sending it) in a periodic update?\n- if we do have separate incomplete/complete flags then definitely need to rename, could use an enum (with a default to avoid encoding in the normal case), definitely need to define clearly what such flags mean (or which conditions they may be used).\n- we should try and keep this as simple as possible (i.e., take it out if it isn't needed).  But we want a solution that is complete.\n- also look at what gNMI does - although that isn't really a great/complete specification in this area.\n\nOther questions that came up in internal discussions are:\n - Is a server just allowed to delay sending updates until it is able to, and then eventually sends an update-complete?\n - If you can't queue the traffic then just tear down the connection - I think that this has been previously suggested/agreed.\n - If you get stuck waiting, i.e., don't time out, then we would just delay sending the update-complete notification.",
      "createdAt": "2025-10-03T16:56:49Z",
      "updatedAt": "2025-10-07T14:26:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "My current thinking is that we should remove the incomplete flag, but perhaps put a tighter constraint on sending an update-complete notification (or setting the \"complete\" flag - renamed from \"update-complete\") in an update notification.\n\nI.e., when a client processes this notification is should be able to infer that if is hasn't received some of the data for a periodic subscription event, and there are no gaps in the sequence-number, then that data no longer exists on the system and can be removed by the client.",
          "createdAt": "2025-10-07T14:26:39Z",
          "updatedAt": "2025-10-07T14:26:39Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOM-PT7s7Qi9jA",
      "title": "Advertising subscription schema",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/11",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The existing YP extensions allow a device to advertise the YANG module at the top of an XPath subscription.  The augmented-by allows a client, using YANG library to retrieve the descendant modules below the subscription point.  Collectively, these can be used to construct a partial YANG schema that covers the subscription nodes.  Note, in the case of OC YANG modules, that make heavy use of groupings, it is possible that some subscriptions may pull in large amounts of YANG schema nodes.\n\nAlternatively, if the clients has access to the full device schema (e.g., through YANG library, or offline YANG packages) then the subscription path could be used to construct a minimal schema that is covered by the subscription (or perhaps the minimum set of modules required to cover the particular schema).\n\nThe solution also needs a way to identify if the subscription has changed so that the schema can be reconstructed.\n\nProposal:\n- Subscription started message always includes the actual filter(s) being used (even if a configured subscription references a filter).\n- Configured subscription also include the referenced filter name, if a referenced (as opposed to inline) filter has been used.\n- We include a string field [max 128 chars] for the publisher to identify the version of the schema under the subscription.  This string field MUST change if any modules under the subscription path have changed.  This field MAY change if modules outside the subscription have changed:\n  - E.g., an accurate way (to minimise churn) would be generate an hash of the compiled schema tree at the point of the subscription (e.g., for a simple YPath subscription).  Done carefully, this should also mean that different devices by the same vendor would have the same schema.\n  - A much simpler alternative would be to include the YANG library checksum, although that is more likely to generate false-positive changes (e.g., when patches of bugfixes are generated), i.e., where the subscription schema has been reported as changed, but there are no actual changes to that part of the schema\n\nAlso consider:\n- In the case of an XPath or YPath subscription, do we also include the modules at the path of the subscription?  Ideally, I would like to find a different, more robust and complete, solution (since this would not identify if any child nodes have changed).\n- If we do move away from listing the modules then we may want a migration path.\n- Is the schema affected at all due to access-control policies (i.e., if the receiver is going to stop receiving some information).  I don't think that it should, it is arguably simpler to be tied solely to the schema.\n",
      "createdAt": "2025-10-09T11:47:51Z",
      "updatedAt": "2025-10-09T14:32:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Some comments from when this was discussed prior to IETF 122:\n   - Rob: I think that we should do this (i.e., as optimized version of content-id)\n   - Would this also be impacted by a change to access control? (Rob: Probably not)\n   - Thomas would like to align to the same mechanism in YANG Push, i.e., in the existing drafts, and we should use the same mechanism\n   - Rob: I would like to understand what the long term complete solution is here.\n   - Benoit: Also related to the data manifest draft (in WGLC in OPSWG.)\n     - Should discuss all of this together.  IETF 122 discussion.\n",
          "createdAt": "2025-10-09T14:29:22Z",
          "updatedAt": "2025-10-09T14:29:42Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOM-PT7s7QlLy9",
      "title": "update-complete notification",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/12",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This replaces the replay-complete notification and may be used on any notification:\n\n- Does this need a flag to indicate that the update-complete notification is due to an initial-sync?  I'm not convinced, but we could potentially just include the *snapshot-type* from the notification message.\n- Check that there is agreement that a single notification is better than too separate notifications (less code paths).\n\n- Should clients have to configure on each subscription that they want to receive update-complete notifications on each subscription (we could also implement a hierarchical default)?  Or is this just default behaviour and these notifications should always be generated?\n\n- Note, that I also have a working assumption that even if a subscription is effectively decomposed internally (e.g., perhaps due to multiple subscription paths) then we would only have a single update-complete notification when all internal subscriptions have completed.",
      "createdAt": "2025-10-09T14:23:12Z",
      "updatedAt": "2025-10-09T14:26:50Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOM-PT7s7Qlbbu",
      "title": "Issues related to dynamic subscription lifecycles",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/13",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for discussion"
      ],
      "body": "When a subscription is terminated, should it be MUST NOT send any more notifications after the terminated message, or SHOULD NOT?\n       \n      - Holger, Thomas, Benoit: MUST NOT\n      - James: SHOULD NOT\n      - MUST NOT is clearer from an implementation POV, but probably doesn't really matter.\n      - What does the receiver do when it gets this message anyway?  I.e., does a receiver check/know to ignore messages received after a subscription-terminated, or before a subscription-started?\n\nProposal: Change the draft to \"MUST NOT\" for now.\n\nRelated question on dynamic-subscriptions:\n- is a terminate-subscription RPC allowed to be asynchronous with respect to the caller.  I.e., is it allowed to return before the subscription has actually stopped?  Or more importantly, after the RPC returns, I think that a client must be able to recreate a new subscription using the same subscription name.\n- is a kill-subscription RPC allowed to be asynchronous with respect to the caller.  I.e., is it allowed to return before the subscription has actually stopped?  For kill-subscription I think that it should be asynchronous - I think that makes more sense given that it generally expected to be a third party and not actively consuming the subscription.\n- Do we wait for a \"establish-subscription\" RPC to return before starting to send events to a client?  YP had this restriction, but I was considering removing it, but I don't know if that would make life more difficult for clients.\n- All of these questions really relate to how much tie there should be better the config and operational flows.",
      "createdAt": "2025-10-09T14:38:14Z",
      "updatedAt": "2025-10-24T15:02:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Proposal:\n- establish-subscription.  If the subscription is accepted then publishers MAY start generating notifications *subscription-started* and *update* notifications before the *establish-subscription* RPC returns.\n- once terminate-subscription returns clients MUST be able to create a new subscription with the same identifier.  It is decoupled from notifications, so *update* and *subscription-terminated* notifications may still be sent after the RPC has returned.\n- *kill-subscription* should be treated the same as a *terminate-subscription*.\n-  the *reset* actions are entirely asynchronous with respect to the caller.  I.e., the publisher can reply to the RPC before starting to process the reset.\n",
          "createdAt": "2025-10-24T11:02:31Z",
          "updatedAt": "2025-10-24T11:02:31Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Benoit/Ebben needs to read offline.\nThomas is okay, as long as, notifications are always in proper order.\n",
          "createdAt": "2025-10-24T15:02:03Z",
          "updatedAt": "2025-10-24T15:02:03Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOM-PT7s7QwH42",
      "title": "On-change events",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/14",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "1. Should we allow on-change events to be published above the subscription path?\n   -  Rob: I think that the answer should be no.\n1. Should we allow on-change events to be generated even if the value may not have changed?\n   - Rob: I think that this needs to be yes, since many systems may track whether something has changed at a higher level in the data tree.  E.g., rather than tracking whether the interface MTU has changed, track whether any of a set of interface properties has changed.\n   - Ebben: How loose or tight should the specification bit.\n   - Holger: This should be okay, and this happens today.\n   - Rob: Should add comment that this shouldn't generate excessive spurious notifications. \n\n1. When subscribed to a leaf under and interface, and the interface is deleted, then what do you generate the delete notification for?\n   - Do you generate the delete for the object being subscribed to?\n   - Or do you send the delete higher up the path, at point that the object has been removed?\n   - If the messages are lifted up to object level then need to consider happen's before relationship (if this is an issue).\n   - Better soln may be to subscribe higher up to the object with a filter applied to select the fields of interface within the object.\n\n1. Should we support configurable subscription-level keepalives?\n   - This would probably entail periodically sending a small message on on-change subscriptions so that the receiver (message broker) knows that the collection is still alive and active.\n   - The presumption is that would be configurable option on an on-change subscription (configured or dynamic)\n   - Note, some transport sessions may already support keepalives, which is a separate, transport specific consideration.\n   - An alternative would be to configure a joint periodic and on-change subscription, but depending on the keepalive interval this would likely involve sending more data on a periodic basis.\n   - Another alternative is to monitor the operational state of the subscription to keep that all the expected subscriptions are active.\n   - **discussed, but no conclusion yet**",
      "createdAt": "2025-10-10T10:27:46Z",
      "updatedAt": "2025-10-16T09:30:58Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDOM-PT7s7RaC0B",
      "title": "Document check/cleanup tasks",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/15",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Document check/cleanup (mostly editorial) tasks:\n\n- [ ] Check/prune terminology, any extra, missing, consistency.\n   - [ ] Should we use the object terminology?\n   - Holger: should try and use same terminology as existing YANG Push RFCs.\n   - Rob: This issue can be a place holder, to go through and check/update the terminology used, and see if any of the referenced terminology isn't needed in YP Lite.\n   - Rob: Update, possible should refine the definition of object to make it clear that it may refer to a single data node or set of data nodes.\n- [ ] Remove dead/commented text in the draft.\n- [ ] Remove dead/commented code from YANG modules.\n- [ ] Check everyone has been acknowledged.\n- [ ] Check that the change list for add/update messages.\n- [ ] Add and validate examples.\n  - [ ] Some (maybe all) should be validated with the new envelope structure (which requires changes to yanglint to support that format)\n  - [ ] Update the tooling to add folding to the examples, if necessary.\n- [ ] Simplify and update the list of dependencies on the various YANG modules (once the structure of them is more stable).\n",
      "createdAt": "2025-10-14T10:14:11Z",
      "updatedAt": "2025-10-22T17:16:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOM-PT7s7Rq2TD",
      "title": "Advertising support for the subscription config data model",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/16",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Should this just use the standard mechanisms, i.e., whether the module is included in YANG library (RFC 8525), or should this also be listed in the Yang Push Capabilities Data Model?",
      "createdAt": "2025-10-15T11:51:56Z",
      "updatedAt": "2025-10-15T11:51:56Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 17,
      "id": "I_kwDOM-PT7s7R9LGn",
      "title": "Transport (and encoding) considerations for subscriptions over multiple receivers",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/17",
      "state": "CLOSED",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for discussion",
        "proposed resolution"
      ],
      "body": "Note I've updated the document to allow a single configured subscription to have different transports - I was trying to avoid this to keep it simple, but as soon as you secure transports any benefit you would have disappears anyway, so the limitation doesn't really help in the general case.\n\nHowever, the current draft only allows for a single encoding per subscription.\n\nAlso a generate note that the transports section has been updated, particularly the transport considerations and should be re-reviewed.",
      "createdAt": "2025-10-16T15:49:25Z",
      "updatedAt": "2025-12-08T10:45:44Z",
      "closedAt": "2025-12-08T10:45:44Z",
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Previous notes when this was discussed:\n   - Rob: Note, it is always possible for a client to setup different subscriptions.\n   - Thomas: This could be useful, e.g., when migrating from one encoding to another, particularly, if it reduced the load on the publisher (compared to creating a new separate subscription).\n   - Rob: I don't think that we would end up optimizing for this case (but would need to check).\n   - Also need to check with Nokia/Huawei would support this.\n   - **Current status: Left open for further discussion.**\n   - Note: This may also have a minor impact on the data model.",
          "createdAt": "2025-10-22T17:51:29Z",
          "updatedAt": "2025-10-22T17:51:29Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Propose closing: the intention is only support a single receiver per subscription.",
          "createdAt": "2025-11-10T13:42:57Z",
          "updatedAt": "2025-11-10T13:42:57Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOM-PT7s7R9Loj",
      "title": "Conformance & Capabilities",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/18",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Do we advertise conformance via capabilities and/or YANG features, or NETCONF capabilities.\n\nProposal:\n- We should use YANG features where appropriate, for coarse granularity (e.g., whether to support dynamic subscriptions), but minimise YANG features for single leaves, where we should be pushing for consistency, or the use of deviations.\n- We should use capabilities to advertise more precise details that cannot be expressed cleanly/nicely through the list of supported modules or features.\n- YP Lite uses a separate capabilities tree from YP because it is a separate protocol with different capabilities and to avoid any confusion.\n\nDo we need to add capabilities to indicate:\n\n1. Which fields are on-change notifiable?\n    - There is a concern that this could be a very long list, or is that okay?\n    - Would there be better ways to group this information, e.g., per-module?\n1. Are there optimised paths within the schema tree that should be advertised.  E.g., the points at which a device may decompose subscriptions to, or publish data separately.\n1. ~Support for CBOR vs CBOR-SIDs~ - Rob: this is already covered by having separate identities for cbor vs cbor-sids encoding.\n\nFor on-change, should a subscription be rejected (or not brought up) if there are no on-change notifiable nodes?  Alternative is to offer implementation flexibility between these two approaches.\n   - Holger: Prefer for the subscription to be rejected.",
      "createdAt": "2025-10-16T15:50:00Z",
      "updatedAt": "2025-10-23T10:52:03Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 19,
      "id": "I_kwDOM-PT7s7TBMfj",
      "title": "Subscription identifiers (string vs numeric)",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/19",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for discussion",
        "propose closing"
      ],
      "body": "YP used numeric identifiers with a purpose statement.  These are harder to manage (and much less meaningful identifiers for clients, but have the advantage that they are small in notifications.\n\nYP Lite has been changed to primarily use named identifiers (max 64 chars), with purpose renamed to description.\n\nThe current YP Lite design is for:\n- the device to allocate numeric ids when the subscription is instantiated, which are included in the subscription started notification\n- the numeric values are used in update messages (to save space).\n- this requires clients to maintain a mapping between the configured subscription name and the dynamic subscription.\n\nSome design alternatives are:\n1. go back to using numeric identifiers (I really don't like this option)\n1. use the named identifier rather than a numeric identifier in the update messages.  This would be slightly less efficient for small updates, but probably won't make much difference in most messages.\n   1. allow clients to optionally also configure/provide the numeric id, but with the name still being the primary key.  The publisher would allocate the numeric id if the client hadn't provided it. \n   2. allow clients to optionally also configure/provide the numeric id, but with the name still being the primary key.  The messages would use the named identifier unless a numeric id had also been provided, in which case that would be used.  Note, that we don't even need to force the numeric-id to be unique, you could just leave it to the client to manage the namespace of numeric ids.\n\nFor dynamic subscriptions, although thought is that we could allow the RPC to exclude both name and id, and have the device allocate the id, and construct a name like \"dyn-<allocated-id>\"\n\nFinally, should we put any other restrictions on the identifier, e.g., disallow spaces, or restrict it to something like \"a-zA-Z0-9-_\".  I'm thinking that we should probably keep this unrestricted in the spec, leaving it to the implementation, but perhaps saying that all implementations MUST support \"a-zA-Z0-9-_\", but MAY support additional characters.",
      "createdAt": "2025-10-22T10:42:29Z",
      "updatedAt": "2025-12-09T10:28:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "I've committed and pushed as change that enacts this:\n- Currently restricted characters to up to 64 chars, with this regex pattern statement : pattern '[A-Za-z0-9._-]+';\n- For dynamic subscriptions, specifying the name is optional, otherwise the server must assign starting with the prefix \"dyn-\".\n- *Is this too restrictive, should we allow non-ASCII characters for subscription ids?  I think that we probably want to avoid spaces regardless.*\n- We also have names for receiver and filter.  I was considering whether we should similarly restrict those or not.",
          "createdAt": "2025-12-08T11:37:35Z",
          "updatedAt": "2025-12-08T11:37:35Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Related to this was a short discussion of what happens if a user configures a subscription that conflicts with a dynamic subscription:\n- From our perspective, we would allow the configured subscriptions to have priority over a dynamic subscription with a conflicting id (i.e., so that if a config has been accepted as valid by the system would still be valid over say a device restart).  Note, this is what the draft currently states because I wrote the text before the discussion 2 weeks ago.\n- James has suggested that they would reject the config if the configured subscription id conflicts with an existing dynamic subscription.\n- It would be good to discuss/close on this one. ",
          "createdAt": "2025-12-08T11:52:32Z",
          "updatedAt": "2025-12-08T11:52:32Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Consensus on 8th Dec is to do the following:\n- Reserve \"dyn-\" for server allocated dynamic subscriptions, reject for any client provided id (configured or dynamic).\n- Clashing config id tears down dynamic subscription with same id.  Clashing dynamic id with configure subscription is rejected.\n- Id is optional to specify for dynamic subscription (same as YP today).\n- Limited the characters to basic ASCII, and 64 chars.  Also imposed a similar limit on receiver and filter names.\n- Added a leaf to the operational tree to indicate whether it is a configured or dynamic subscription.",
          "createdAt": "2025-12-09T10:23:08Z",
          "updatedAt": "2025-12-09T10:23:08Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Please check commits above (some changes were already made), and I also propose closing this issue.\n",
          "createdAt": "2025-12-09T10:28:03Z",
          "updatedAt": "2025-12-09T10:28:03Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOM-PT7s7TCVi1",
      "title": "Subscription-filters (referenced filters and multiple-filters)",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/20",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for discussion"
      ],
      "body": "The current draft:\n\n- Basic dynamic subscriptions require the subscription filter to be specified inline.\n\n- The IETF config model:\n  - allows filters to be specified inline, but also allows a reference to a filter (i.e., same as RFC 8641). \n  - also augments the dynamic establish-subscription RPC to allow a dynamic subscription to reference a configured subscription.\n\nThe subscription-started notification always includes the filter inline (even if it was referenced).  If the subscription was created using a referenced filter, then the name of the referenced filter is also included in the subscription started.\n\nIf a subscription is allowed to contain multiple filter paths then there is a question to whether a subscription would be allowed to referenced multiple filters.",
      "createdAt": "2025-10-22T12:11:09Z",
      "updatedAt": "2025-10-24T14:51:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "     - Thomas: Do we need referenced filters at all?  Subscriptions could be simplified if everything was done inline.\n     - gNMI is only done inline.\n     - Juniper also supports filters.\n     - Thomas try to simplify as much as possible, then do we need templating?",
          "createdAt": "2025-10-22T12:14:32Z",
          "updatedAt": "2025-10-22T12:14:32Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Ebben:\n- Discussed adding an if-feature statement for filter-ref into dynamic subscription, but probably not needed.\n- Propose closing this issue.",
          "createdAt": "2025-10-24T14:51:46Z",
          "updatedAt": "2025-10-24T14:51:46Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOM-PT7s7TCXdI",
      "title": "Subscription-filters (do we allow multiple paths)",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/21",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The current draft restricts a subscription filter to a single ypath, xpath, or subtree filter.\n\nHaving a single subtree filter makes sense, but should we allow a single subscription to reference multiple paths?\n\nIIRC, James is in favour, Thomas thinks that this may be too much complexity (and I believe has a particular concern about being able to easily represent the schema associated with the subscription).",
      "createdAt": "2025-10-22T12:13:27Z",
      "updatedAt": "2025-10-22T12:13:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 22,
      "id": "I_kwDOM-PT7s7TDC-n",
      "title": "Is a publisher allowed to arbitrarily send a sync-on-start resync, e.g., if it detects data loss, or should it always just terminate and reinitialize the subscription?",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/22",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "    - Holger, terminate & recreate.\n    - gNMI, not specified.\n    - Thomas: Keep this as implementation detail.\n    - Sequence-id indicates that a client is dropping message anyway.\n    - Receiver can already monitor and see that there is a problem anyway.\n\nCurrent proposed text:\n\n```\nIn addition, publishers are not required to notify every change or value for an on-change monitored data node.  Instead, publishers MAY limit the rate at which changes are reported for a given data node, i.e., effectively deciding the interval at which an underlying value is sampled.  If a data node changes value and then reverts back to the original value within a sample interval then the publisher MAY not detect the change and it would go unreported.  However, if the data node changes to a new value after it has been sampled, then the change and latest state are reported to the receiver.  In addition, if a client was to query the value (e.g., through a NETCONF get-data RPC) then they MUST see the same observed value as would be notified.\n```",
      "createdAt": "2025-10-22T13:03:43Z",
      "updatedAt": "2025-10-22T13:03:43Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 23,
      "id": "I_kwDOM-PT7s7TDGck",
      "title": "If the parameters for a subscription change in any way then do we want to say that the subscription MUST be killed and recreated?",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/23",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "If the parameters for a subscription change in any way (e.g., the config changes for a configured subscription, or a referenced filter changes in a dynamic subscription) then do we want to say that the subscription MUST be killed and recreated.  I.e., with subscription-terminated/subscription-started notifications? \n\n - Holger, kill/re-create.\n - Collector would need to know.\n - Ebben: Includes addition or deletion of the path.\n - Benoit: Which parameters are changing, this could impact.  It depends.  Maybe forcing it down keeps it simple.  Would need further definition of what parameters would cause this to be pulled down.\n - Locally relevant, e.g., modifying transport parameters doesn't force a change.\n - Benoit: If you are not sure what you are doing you must recreate.\n\nCurrent draft describes the conditions under which subscriptions must be destroyed and recreated, which includes most configuration changes.  Propose closing this issue.",
      "createdAt": "2025-10-22T13:07:39Z",
      "updatedAt": "2025-10-22T13:07:39Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDOM-PT7s7TDXcL",
      "title": "Reset Action",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/24",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for discussion"
      ],
      "body": "   - There seems to be consensus that having/keeping such a YANG action is useful if a configured subscription is stuck.\n   - Further discussion is needed to indicate where such an RPC should be in the data model, and what effect it should have:\n      - It could be under the subscription list, which would effectively be equivalent to forcing the subscription to terminate and re-initialize across all receivers.\n      - It could also be under the receiver list, which would effectively be equivalent to forcing all subscriptions using that receiver to terminate and re-initialize.\n      - **We also need to consider whether this would clear subscription counters or not.**\n         - RobW - it should do whatever terminating and recreating the subscription does.  Some counters would expect to be updated, others not.\n      - **Rob: I've written up some text for the reset action on a subscription and under the receiver (that applies to all subscriptions that reference the receiver configuration).  Unlike the existing reset action, I've removed the return parameter (timestamp of when it took effect), and I think that we should allow it to be processed asynchronously w.r.t the RPC caller.  Authors, please check the latest text.**",
      "createdAt": "2025-10-22T13:26:08Z",
      "updatedAt": "2025-12-09T11:57:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "I think that the current text needs to be tweaked a bit since it states to treat it as a config removal/addition, but I think that this should instead be regarded as a config change and I think that any counters associated with the subscription should be preserved rather than being reset.",
          "createdAt": "2025-10-24T10:43:11Z",
          "updatedAt": "2025-10-24T10:43:11Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Action on other authors to read and refer back if they are okay with the text.",
          "createdAt": "2025-10-24T14:39:52Z",
          "updatedAt": "2025-10-24T14:39:52Z"
        },
        {
          "author": "jgcumming",
          "authorAssociation": "NONE",
          "body": "Can you link to the commit that has the specific wording changes please Rob?",
          "createdAt": "2025-12-08T16:17:04Z",
          "updatedAt": "2025-12-08T16:17:04Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "I haven't been strict enough splitting up the commits, so that would be tricky, probably best to look at the text here:\n\nIf you look at sections https://rgwilton.github.io/draft-yp-observability/draft-wilton-netconf-yang-push-2.html#name-resetting-a-configured-subs.\n\nBut this is still treating a reset as a delete and create, but we now have a modify action, hence I think that there is argument that a reset should be less impactful, e.g., not resetting the counters that you would expect with a delete then re-creation.",
          "createdAt": "2025-12-08T16:51:10Z",
          "updatedAt": "2025-12-08T16:51:10Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Agreement on 8th Dec is:\n- Reset on subscription is equivalent to delete & re-create of the subscription which also causes any associated counters to be reset.\n\nWe have not explicitly confirmed the behaviour on calling reset on the receiver, i.e., equivalent to removing and re-adding the receiver config.  This is slightly different than the alternative which would be to treat the operation as a reset (delete/re-add) of every subscription referencing the receiver.  Need to check with Thomas/Holger on what, if any expectations they would have here.",
          "createdAt": "2025-12-09T11:57:04Z",
          "updatedAt": "2025-12-09T11:57:04Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOM-PT7s7TGREW",
      "title": "What is the new protocol called?",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/25",
      "state": "CLOSED",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for discussion"
      ],
      "body": "Is it yang-push-2 or yang-push-lite.\n\nRelated:\n- what are the name of the YANG modules? (probably should minor the draft)\n- what is the name of the top level container?",
      "createdAt": "2025-10-22T17:02:02Z",
      "updatedAt": "2025-12-09T10:45:35Z",
      "closedAt": "2025-12-09T10:45:35Z",
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "The latest version to github has been labelled as YANG Push v2.",
          "createdAt": "2025-11-24T16:49:14Z",
          "updatedAt": "2025-11-24T16:49:14Z"
        },
        {
          "author": "jgcumming",
          "authorAssociation": "NONE",
          "body": "If we are to do this, then part of this work should be to obsolete the old version IMHO.",
          "createdAt": "2025-12-08T16:10:16Z",
          "updatedAt": "2025-12-08T16:10:16Z"
        },
        {
          "author": "earies",
          "authorAssociation": "NONE",
          "body": "agreed - v2 implies the next evolution + replacement of prior imo.... other than existing implementation, the guidance is really meant to be that any prior version of this work not be the target of future implementation",
          "createdAt": "2025-12-08T16:24:23Z",
          "updatedAt": "2025-12-08T16:24:23Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "> If we are to do this, then part of this work should be to obsolete the old version IMHO.\n\nThe intention is that at least initially this can live along side an older implementation.  Strategically, it might be better to delay any discussion about whether this should deprecate YANG Push until the draft is a lot more progressed (e.g., close to being finished).",
          "createdAt": "2025-12-08T16:53:20Z",
          "updatedAt": "2025-12-08T16:53:20Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Agreement was that we should call this Yang Push v2 for now.  And then wait to see if there is any further WG feedback.",
          "createdAt": "2025-12-09T10:32:54Z",
          "updatedAt": "2025-12-09T10:32:54Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOM-PT7s7TGXa7",
      "title": "Do we need to fold in any text from RFC 8640 and RESTCONF?",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/26",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for discussion"
      ],
      "body": "I.e., there was this text in the one of the previous docs:   Bindings for subscribed event record delivery for NETCONF and RESTCONF are defined in **RFC 8640** and **RFC 8650**, respectively.\n   - Rob: If text is needed for NETCONF and/or RESTCONF then I suspect that it would be better added to this document than to require small separate documents (as was done before).\n   - But ideally, we would try and keep the text as common/generic as possible and minimise the amount of text needed for NETCONF or RESTCONF specifics.  E.g., perhaps they are just informational example drafts.",
      "createdAt": "2025-10-22T17:11:18Z",
      "updatedAt": "2025-10-24T10:53:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Both RFC 8640 and RFC 8650 are about 20 long.\n\nDo we fold the NETCONF doc into the core YP Lite spec?  Or do we keep it as a separate document, which I think would mean that some of examples currently in YP Lite regarding creating/managing subscriptions would move out to the separate document and be referenced.\n\nThe same question applies to RESTCONF.\n\nI.e., the core question is how much better is it to have a single doc that contains everything vs a small set of documents, e.g.,:\n1. core protocols (including notifications and RPC definitions)\n1. ietf config/oper data model\n1. YP Lite binding/examples for NETCONF\n1. YP Lite binding/examples for RESTCONF\n1. envelope (expect to reuse existing envelope draft)\n1. udp-notif (bis, or YP-Lite version of draft is needed).\n",
          "createdAt": "2025-10-24T10:53:26Z",
          "updatedAt": "2025-10-24T10:53:26Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOM-PT7s7TGZXg",
      "title": "Create bis version of draft-ietf-netconf-udp-notif",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/27",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "draft-ietf-netconf-udp-notif augments into the YP Notif receiver namespace, whereas YP-Lite uses a separate namespace so their would need to be a bis version of udp-notif, or udp-notif-yp-lite that augments into the separate receiver tree (possibly with some slight config tweaks as well)?\n\n",
      "createdAt": "2025-10-22T17:14:18Z",
      "updatedAt": "2025-10-22T17:14:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 28,
      "id": "I_kwDOM-PT7s7TGwVO",
      "title": "Do we need a receiver-disconnected notification?",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/28",
      "state": "CLOSED",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for discussion",
        "proposed resolution"
      ],
      "body": "The draft currently documents this.\n\nThis is only lifecycle notification that would be send to a single receiver (which would either mean a gap in sequence numbers or a duplicate sequence number for that message ...)\nIf the receiver disconnected then it wouldn't get the message anyway.  Hence, the most realistic case that a receiver would get this message is if a receiver was unconfigured for a subscription, and an alternative action could be to just flap delete/re-create the subscription since it is a config change.\n- probably the delete-subscription/create-subscription notification should include an enum to indicate why that particular event occurred.\n- also what action is taken if a receiver is added, do we still flap the subscription?  Is that an issue?\n\nComments from discussing this previously:\n1. Do we need a per-receiver notification to indicate to a specific receiver that it has been disconnected?\n   - This would seem to only apply to configured subscriptions (since dynamic cannot have more than one receiver).\n   - If the transport session went down, then the publisher would be expected to reconnect anyway.\n   - So, the specific use case is likely to be unconfiguring a receiver for a subscription that has multiple receivers.\n   - **Currently parked for further discussion.**",
      "createdAt": "2025-10-22T17:45:18Z",
      "updatedAt": "2025-12-08T10:44:36Z",
      "closedAt": "2025-12-08T10:44:36Z",
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "My latest thoughts:\n- We should get rid of a per receiver message.\n- Need to think carefully whether flapping the entire subscription when a receiver is added/removed is the right choice?\n- Possibly subscription-started message should list the count or names of the active receivers (although the names are logically only a locally scoped identifier on the device).",
          "createdAt": "2025-10-22T17:46:43Z",
          "updatedAt": "2025-11-05T15:04:29Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "- Thomas: Prefers notification are on subscription, okay with subscription-terminated & subscription-started message if we lose a receiver.\n- Benoit - Do we need to consider the impact of different transports (e.g., UDP wouldn't notice, but DTLS would)?\n- Thomas/Benoit - Do we really need to support multiple receivers at all?  + Ebben?  I.e., could just force the client to configure multiple subscriptions.\n- Park for further discussion.",
          "createdAt": "2025-10-24T14:37:14Z",
          "updatedAt": "2025-11-05T15:03:40Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "All messages are processed at the subscription level, so per subscription message is removed.\n\nFor adding receivers:\n- subscription-started notification includes count of number of receivers (defaults to 1, so only included if there is more than on receiver.\n- a new subscription-started notification is sent out (to all receivers) if a receiver is added.\n\nFor removing receivers:\n- subscription-terminated notification is sent out (to all receivers)\n- terminated-reason: \"receiver removed\"\n- new subscription-started notification is sent out (to all receivers) indicating the current receiver count and includes the reason.",
          "createdAt": "2025-11-05T17:18:50Z",
          "updatedAt": "2025-11-05T17:18:50Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Propose closing: the intention is only support a single receiver per subscription.\n\nAlso see #17 ",
          "createdAt": "2025-11-10T13:45:10Z",
          "updatedAt": "2025-11-10T13:45:10Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOM-PT7s7THBDS",
      "title": "YPath",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/29",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "1. This draft introduces a new simple yang path (ypath) format that is like a JSON instance data path, that all implementations MUST support.\n   - Vendors already support a simple JSON like path (e.g., using module-names rather than XML namespaces).\n   - **Open questions (for further discussion):**\n      - Do we support filtering on non-keys, e.g., this example from Thomas (but which filters on a non-key):\n         /if:interfaces-state/if:interface\\[if:type='ianaift:ethernetCsmacd'\\]/if:statistics\n      - Do we support simple regex filtering on the keys (and if so, how would that be expressed, would it be compatible with JSON Path)\n      - Do we need any more complex filtering (e.g., Holger's example of only getting entries from a list if they are in a particular state.), or do we always use subtree filters for that?\n   - **Authors: I provides some suggested text in {{YPaths}}, but I expect further discussion may be needed. (E.g., how multiple keys should be expressed)**",
      "createdAt": "2025-10-22T18:06:33Z",
      "updatedAt": "2025-11-02T15:31:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "Andy commented that we should probably split this out into a separate draft.",
          "createdAt": "2025-11-02T15:31:30Z",
          "updatedAt": "2025-11-02T15:31:30Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOM-PT7s7THDep",
      "title": "General comments on YANG Push Lite Configuration Model",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/30",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Note some of these apply or impact dynamic subscriptions as well.\n\n1. YP Lite is somewhat different (separate namespace, separate receivers, no event filters, some config has moved to a separate receivers list.)  See the data model and {{DifferencesFromYangPush}}.\n\n1. We should allow devices to limit which datastores subscriptions can be made against (e.g., not candidate or factory-default as some obvious examples).  Should these be advertised in the capabilities?\n\n1. (James) Should we even document the configuration data model in this document at all, or should it be in a separate document?\n\n1. Some other changes/proposed changes:\n   - I've removed some of the YANG features for 'small' one/two changes in configuration.  I propose that we don't need features for these at all (e.g., DSCP settings), or in other cases we can use operational capabilities, or rely on deviations.\n      - I've renamed the encodings (e.g., from \"encode-json\" to just \"json\")\n\n      - Maybe further simplification of the receivers list under the subscription.  E.g., do we need stats per subscription per receiver, or just per subscription?  Do want stats across all subscriptions to a given receiver?\n        - Holger: Stats per subscription should be sufficient.  No need for per subscription/pre-receiver stats (which would allow the data model to be simplified a little bit).\n\n      - Subscription-ids are currently numeric values with the space split between configured and dynamic subscriptions, but I think that the config model would be cleaner if we used names for the configured subscriptions (and we could reserve a prefix \"dyn-\" for dynamic subscriptions).\n        - Holger, Rob: Strong preference to names.\n        - Thomas, keep ids, but rename 'purpose' to name.  Also give receivers an ids and be keyed this.\n        - See #19 for more details.",
      "createdAt": "2025-10-22T18:09:11Z",
      "updatedAt": "2025-10-22T18:11:34Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 31,
      "id": "I_kwDOM-PT7s7TOvlY",
      "title": "What operational data should be reported and how should it be structured?",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/31",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "1. Should we define some additional operational data to help operators check that the telemetry infrastructure is performing correctly, to get an approximation of the load, etc.\n   - Rob: probably, but lower priority.\n\n1. Should dynamic subscriptions use the same receivers structure as for configured subscriptions, or should they be inline in the configured subscription?\n   - Thomas: Two sets of counters, one is at the subscription which is about fetching the data, and the other is on the receiver.\n   - James: Can think of some uses cases where listing drop counters per subscription may be helpful.\n   - Rob: Thinking about it further, it probably needs to be separate, since for some transports, each subscription may open a separate transport session to the receiver rather than trying to mux into a single transport (e.g., TCP).\n   - Rob: Proposal: Dynamic subscriptions don't appear in the receivers list.  What additional specific diags information is needed for dynamic subscriptions?  Is any of this transport specific and hence must be deferred to transport specific augmentations?",
      "createdAt": "2025-10-23T09:23:10Z",
      "updatedAt": "2025-12-09T11:49:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "We should also consider https://github.com/rgwilton/draft-yp-observability/issues/24.\n\nSpecifically, we say that a reset on a subscriber is equivalent to removing and re-adding the subscriber config, and a reset on a receiver is equivalent to removing/re-adding the receiver configuration for all subscribers that reference the receiver, that will force the subscriptions to be terminated and recreated.\n\nAre the subscriber counters reset if a receiver goes down and comes up again?  If they are reset, then presumably the reset action should only occur when the subscription comes back up again.",
          "createdAt": "2025-12-09T11:49:45Z",
          "updatedAt": "2025-12-09T11:49:45Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOM-PT7s7TOzcF",
      "title": "*update* notification message format",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/32",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This high level issue is track issues/discussion related to the *update* notification message format:\n\n1. We allow multiple updates within a single message (primary use case is for the on-change case).  What about the timestamp, which is still just once per message (like gNMI)?  Should message bundling be optional/configurable to implement (if they all use a single shared timestamp)?\n\n   - on-change deletes are implicit by an update that replaces an existing entry with an empty data node (e.g., \"{}\" in JSON)\n\n     - An alternative choice here could be an explicit delete flag, we need to decide which would be simpler/better.\n\n   - The update message also currently includes a path-prefix to allow (like gNMI) so that they don't necessarily need to be encoded from root, specifically, I think that this makes on-change messages nicer, since the on-change is rooted to the thing that is changing rather than the root of the tree.  We need to define semantics of how this works, e.g., this should probably be controlled via configuration.\n      - Ideally, the path prefix would be exactly the same as the YPath format that is being specified for configuration.\n\n     - Thomas: We should keep this.\n\n  - *Further discussion of this issue is needed*",
      "createdAt": "2025-10-23T09:27:22Z",
      "updatedAt": "2025-10-23T09:27:22Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 33,
      "id": "I_kwDOM-PT7s7TP9Rk",
      "title": "NACM filtering (and other security considerations)",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/33",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "1. Need to consider how NACM applies to YANG Push Lite, which may differ for dynamic vs configured subscription, but generally we want the permissions to be checked when the subscription is created rather than each time a path is accessed.\n\n   - (James) Take out tight binding to NACM from YANG Push Lite altogether.  I.e., decouple YANG Push Lite from what security mechanism is being used.\n\n   - (Rob) Another choice could be to use NACM as an example rather than the only way.\n\n1. Where should this be in the document (current it in the security considerations section)\n\n1. Do we want to retain the the current text in {{events}} introduction related to terminating a subscription if permissions change?\n\n1. Also note, text was removed from the transport section related to RPC authorization, and which should be moved to an application (rather than transport) layer security mechanism.",
      "createdAt": "2025-10-23T10:55:27Z",
      "updatedAt": "2025-10-23T10:55:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 34,
      "id": "I_kwDOM-PT7s7WHAm_",
      "title": "Don't require a subscription-terminated notification if it isn't necessary.",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/34",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "If the configuration is being changed, then a new subscription-started notification should be sufficient.  We should minimise the cases of when we generate a subscription-terminated notification to when they are needed.",
      "createdAt": "2025-11-05T17:44:53Z",
      "updatedAt": "2025-11-05T17:44:53Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 35,
      "id": "I_kwDOM-PT7s7X3AFf",
      "title": "How to handle empty containers in a response",
      "url": "https://github.com/rgwilton/draft-yp-observability/issues/35",
      "state": "OPEN",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Should we mandate that empty containers are removed from the output or leave this as an implementation decision, on the assumption that mandating that they are included makes no sense.  Either way, I think that it would be good for the draft to be explicit on this point - i.e., a known unknown.",
      "createdAt": "2025-11-13T14:42:25Z",
      "updatedAt": "2025-11-13T14:42:25Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOM-PT7s5_U7md",
      "title": "Rgwilton initial revision",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/1",
      "state": "MERGED",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-21T14:04:52Z",
      "updatedAt": "2024-10-21T14:49:00Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "62558a10c783834c83bd41f198d1fc56aa68bfcb",
      "headRepository": "rgwilton/draft-yp-observability",
      "headRefName": "rgwilton-initial-revision",
      "headRefOid": "b42ff8be18060b7b19aae73ae397ae5934858ac7",
      "closedAt": "2024-10-21T14:49:00Z",
      "mergedAt": "2024-10-21T14:49:00Z",
      "mergedBy": "rgwilton",
      "mergeCommit": {
        "oid": "df557872aa90384a2de7d5c567e5d492444c3125"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOM-PT7s5_YETj",
      "title": "Rgwilton initial revision",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/2",
      "state": "MERGED",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-21T21:07:22Z",
      "updatedAt": "2024-10-21T21:09:08Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "8bf2842c41ba3384b7086696703acbe84a30f395",
      "headRepository": "rgwilton/draft-yp-observability",
      "headRefName": "rgwilton-initial-revision",
      "headRefOid": "2d92e8d09e1f142208ae94bb34574dd7b7301784",
      "closedAt": "2024-10-21T21:09:01Z",
      "mergedAt": "2024-10-21T21:09:01Z",
      "mergedBy": "rgwilton",
      "mergeCommit": {
        "oid": "ce4b85ad251fef2e90bc0a6b5b44f5305e6ba2b8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "PR_kwDOM-PT7s5_YGhB",
      "title": "Rgwilton initial revision",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/3",
      "state": "MERGED",
      "author": "rgwilton",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-21T21:14:17Z",
      "updatedAt": "2024-10-21T21:15:07Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "ce4b85ad251fef2e90bc0a6b5b44f5305e6ba2b8",
      "headRepository": "rgwilton/draft-yp-observability",
      "headRefName": "rgwilton-initial-revision",
      "headRefOid": "fff6f25057a509a8fb6c41efe222f619c9b15195",
      "closedAt": "2024-10-21T21:15:01Z",
      "mergedAt": "2024-10-21T21:15:01Z",
      "mergedBy": "rgwilton",
      "mergeCommit": {
        "oid": "f1fd1ed3fc3e7df6608553e0dd97c0d8bd8d9142"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 5,
      "id": "PR_kwDOM-PT7s6BL9e8",
      "title": "Jgc 01",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/5",
      "state": "CLOSED",
      "author": "jgcumming",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-11-07T13:15:26Z",
      "updatedAt": "2024-11-07T13:15:57Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "d5488db948318c4788c7b7aaffdd2648e2a6ce1d",
      "headRepository": "jgcumming/draft-yp-observability",
      "headRefName": "jgc-01",
      "headRefOid": "cb9d0e2cfb12a35071d82eb831b9f780928044a1",
      "closedAt": "2024-11-07T13:15:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 6,
      "id": "PR_kwDOM-PT7s6BMGaH",
      "title": "WIP: Updates to specify YANG push lite",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/6",
      "state": "OPEN",
      "author": "jgcumming",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-11-07T13:31:40Z",
      "updatedAt": "2025-02-04T09:58:02Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "d5488db948318c4788c7b7aaffdd2648e2a6ce1d",
      "headRepository": "jgcumming/draft-yp-observability",
      "headRefName": "jgc-01",
      "headRefOid": "6a16d71643ee9767f01036d51b3ebb85fd432aee",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "earies",
          "authorAssociation": "NONE",
          "body": "are we ready to merge this PR and iterate from there?",
          "createdAt": "2024-12-08T17:46:44Z",
          "updatedAt": "2024-12-08T17:46:44Z"
        },
        {
          "author": "jgcumming",
          "authorAssociation": "NONE",
          "body": "@rgwilton I've not had time to devote to this over the holiday period.  Feel free to merge and then continue and I'll add more changes to the merged version",
          "createdAt": "2025-02-03T22:12:57Z",
          "updatedAt": "2025-02-03T22:12:57Z"
        },
        {
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "body": "I'll need to manually merge this in because I have iterated significantly on the document.  The latest version is on the main branch in [draft-wilton-netconf-yang-push-lite.md](https://github.com/rgwilton/draft-yp-observability/blob/main/draft-wilton-netconf-yang-push-lite.md).\r\n\r\nAnd you can see the generated document here:\r\nhttps://rgwilton.github.io/draft-yp-observability/draft-wilton-netconf-yang-push-lite.html\r\n\r\nI would like to check whether you are still okay with this as a starting point and for me to add your names to this draft?",
          "createdAt": "2025-02-04T09:58:00Z",
          "updatedAt": "2025-02-04T09:58:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOM-PT7s6QcIdj",
          "commit": {
            "abbreviatedOid": "a116515"
          },
          "author": "earies",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T10:10:48Z",
          "updatedAt": "2024-11-08T10:10:49Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nThe establish-subscription operation is extended with an \"encoding\" option to determine the encoding type.  This \"encoding\" leaf is an identityref with the following defined identities: xml, json_ietf, cbor\r\n```\r\nThis enables better extensibility (should one choose to augment additional encodings at a later point)",
              "createdAt": "2024-11-08T10:10:49Z",
              "updatedAt": "2024-11-08T10:10:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOM-PT7s6RB0t4",
          "commit": {
            "abbreviatedOid": "6a16d71"
          },
          "author": "rgwilton",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-11-13T13:35:24Z",
          "updatedAt": "2024-11-13T13:35:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOM-PT7s6MgDJ1",
      "title": "Fix replay-completed.txt reference",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/7",
      "state": "OPEN",
      "author": "earies",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-25T16:30:21Z",
      "updatedAt": "2025-02-25T16:30:21Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "b6c6f5d6672256754673adf0f8c483cb884c9969",
      "headRepository": "earies/draft-yp-observability",
      "headRefName": "replay-completed",
      "headRefOid": "2862f6a5a6a1d02d670d8f31dfe7c4414b32585b",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 36,
      "id": "PR_kwDOM-PT7s64M5C9",
      "title": "Update affiliations",
      "url": "https://github.com/rgwilton/draft-yp-observability/pull/36",
      "state": "OPEN",
      "author": "earies",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-12-10T18:40:32Z",
      "updatedAt": "2025-12-10T18:40:32Z",
      "baseRepository": "rgwilton/draft-yp-observability",
      "baseRefName": "main",
      "baseRefOid": "0cf2eb7de1a36efef915c7fc64bb7ad87b59a516",
      "headRepository": "earies/draft-yp-observability",
      "headRefName": "contact-info",
      "headRefOid": "566f9a6b65cfec2978675b0a9f2107ad3b739127",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}